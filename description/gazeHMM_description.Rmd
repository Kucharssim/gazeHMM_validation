---
title: "gazeHMM Description"
author: "Malte LÃ¼ken"
date: "27.04.2020"
output: pdf_document
---

# General

The algorithm is divided in three parts: Preprocessing, classification, and postprocessing.

Input: x-coordinate, y-coordinate, timestamp, unit of coordinates (px vs. va), screen resolution, screen dimensions, 
distance to screen, sampling rate, blink indicator, number of states in the HMM, start values for the HMM, downsampling factor,
control options for fitting the HMM.


# Preprocessing

1. The algorithm checks whether samples are valid: Samples for which the x- or y-coordinates are NA, infinity, or (0,0) are marked (internally) as invalid.

2. Samples that match the blink indicator are labeled as blinks.

3. If the unit is px, the x- and y-coordinates are transformed into va with: 
    i. The coordinates are centered ([0,0] is center)
    ii. $\theta_{deg} = atan(\frac{x*res_x}{d_{screen}*dim_x})\frac{180}{\pi}$

4. Samples that are outside the screen are marked as invalid.

5. A Butterworth filter (3rd order, critical frequency = 0.5 of the Nyquist frequency) is applied to the valid samples (this step is optional).

6. Velocities and accelerations for the x- and y-coordiantes are calculated using a Savitzky-Golay filter (3rd order, length = 5).

7. Combined velocities and accelerations are calculated as: $v = f \sqrt{v_x^2 + v_y^2}$ and $a = f \sqrt{a_x^2 + a_y^2}$ with $f$ as the sampling rate.

8. Velocities and accelerations of value zero are nudged to be 0.01.

9. Samples with velocity above 1000 deg/s or acceleration above 100000 deg/$s^2$ are marked as invalid.

10. The sample-to-sample angle is calculated as: 
$$\theta_t = atan2(\frac{y_{t+1} - y_t}{x_{t+1} - x_t}) - atan2(\frac{y_t - y_{t-1}}{x_t - x_{t-1}}).$$ 
Angles are normalized to $[0,2\pi]$ by adding $2\pi$ to negative values.

11. Samples that have an angle with value NA are marked as invalid.

12. The velocity, acceleration, and angle of invalid samples are set to NA.

Output: Data frame with x-coordinate, y-coordinate, timestamp, velocity, acceleration, angle, and initial label variable with only blinks.


# Classifcation

Input: Data frame from preprocessing and HMM related general input variables.

1. Sets default start values if none are provided. 

2. Downsamples velocity and acceleration.

3. Fits a HMM with velocity, acceleration, and angle as dependent variables. 
Velocity and acceleration are modeled by a two-parameter gamma distribution (shape and scale). 
Angle is modeled by a uniform distribution for the first component and von-Mises distributions (mean and kappa) for further components.

Output: Fitted model.


# Postprocessing

Input: Data frame from preprocessing and posterior state sequence of the fitted model.

1. Relabels posterior states of samples with recursive algorithm:
    i. If a fixation or smooth pursuit sample has no previous or following sample with the same label (single sample event), 
it is relabeled as the label from the previous sample.
    ii. If a PSO sample is followed by a saccade sample or following a non-saccade sample,
it is relabeled as the last different label.
    iii. Saccade events (batch of consecutive saccade samples) below 10 ms are relabeled as the label from the previous event.
    iv. These steps are applied recursively until all conditions hold.

2. For each event (batch of subsequent samples belonging to the same label), the following metrics are computed:
    i. Fixations:
        a. Duration: Max timestamp - min timestamp
        b. Position: Trimmed mean (20%) of x- and y-coordinates
    ii. Saccades, PSOs, and smooth pursuits:
        a. Duration: Max timestamp - min timestamp
        b. Start: First x- and y- coordinates
        c. End: Last x- and y- coordinates
        d. Amplitude: Euclidian distance from start to end
        e. Max. velocity
        f. Avg. velocity
        g. Max. acceleration
        h. Avg. acceleration
        i. Direction: $\theta = atan2(\frac{end_y - start_y}{end_x - start_x})$
    
For duration all samples are used, for the rest only valid samples (from preprocessing).
  
General output: List with a data frame containing the labeled samples, a list with data frames for the different events,
and the fitted model.
  